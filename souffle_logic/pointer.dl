
.comp Pointer {

#if DEBUG
	#if VERBOSE
		.output RootVar
		.output IntraCopyAssign
		.output InterCopyAssign
		.output ExtendedRootVar
		.output ExtendedCopyAssign
		.output ExtendedVarPointsTo
		.output LoadActionParam
		.output StoreActionParamAddress
		.output StoreLoadActionParamAddress
	#endif
	.output StoreLoadActionParam
	.output VarPointsTo
#endif


.decl RootVar(var: Var)

// Root Var includes const, arithmetic result and entry point parameters
RootVar(var):-
	_AssignType(_, var, _),
	!_AssignType(_, var, "Copy"),
	!_AssignType(_, var, "Call").

// Global variable
RootVar("$a").

// Reciever
RootVar("_self").

// Code
RootVar("_code").

// assume uncalled funcation is the entry point
RootVar(var):-
	_FormalArgs(_, func, _, var),
	!_FuncCall(_, _, func).



// copys wihtin function
.decl IntraCopyAssign(insn: Insn, to: Var, from: Var)

IntraCopyAssign(insn, to, from):-
	_AssignVar(insn, to, from),
	_AssignType(insn, to, "Copy"),
	to != "$a".



// taint for action parameter

.decl LoadActionParam(insn: Insn, to: Var, from: Var)

// direct load action data from memcpy
LoadActionParam(insn, to, name):-
	_Load(insn, from, offset, to),
	_AssignVar(_, from, base),
	ActionParam(action, base, offset_symbol, index),
	offset = to_number(offset_symbol),
	AllActionParam(action, index, name).


// sepcial VarPointsTo for action param to avoid double negation
.decl _VarPointsTo(var1: Var, var2: Var)

_VarPointsTo(var, var):-
	RootVar(var).

// Copys
_VarPointsTo(to, var):-
	_InterCopyAssign(to, from),
	_VarPointsTo(from, var).

// store action data directly
.decl StoreActionParam(address: Var, offset: number, var: Var)

StoreActionParam(address, offset, to):-
	_VarPointsTo(var, to),
	LoadActionParam(_, _, to),
	_Store(_, address_var, offset, var), 
	_AssignVar(_, address_var, address).

// store the address that can point to action data
.decl StoreActionParamAddress (dyn_offset: Var, offset: number, address_var: Var, param: Var)

StoreActionParamAddress(dyn_offset, offset, address_var, param):-
	// the store statement for dynOffset
	_Store(_, dyn_offset, offset, address_var), 
	// the store statement for action param
	StoreActionParam(stored_dyn_offset_1, stored_offset, param),
	_AssignType(_,address_var, "Add"),
	// address points to the same place
	_AssignVar(_,address_var, stored_dyn_offset_2),
	_VarPointsTo(stored_dyn_offset_1, var),
	_VarPointsTo(stored_dyn_offset_2, var),
	// the stored offset is same
	_AssignVar(_,address_var, offset_var),
	_SimpleAssign(_, offset_var, num),
	stored_offset = to_number(num).
	

// store + load by calculating offset for stored address
.decl StoreLoadActionParamAddress(insn: Insn, to: Var, stored_address: Var, param: Var)

// load_dyn_offset_root = load_dyn_offset + offset_var
// ..... load_dyn_offset_var <- load_dyn_offset_root
// load(load_dyn_offset_var + load_offset)
StoreLoadActionParamAddress(insn, to, stored_address, param):-
	StoreActionParamAddress(store_dyn_offset, stor_offset, stored_address, param),
	_Load(insn, load_dyn_offset_var, load_offset, to),
	_VarPointsTo(load_dyn_offset_var, load_dyn_offset_root),
	_AssignType(_,load_dyn_offset_root, "Add"),
	_AssignVar(_, load_dyn_offset_root, load_dyn_offset),
	_VarPointsTo(load_dyn_offset, var),
	_VarPointsTo(store_dyn_offset, var),
	_AssignVar(_, load_dyn_offset_root, offset_var),
	_SimpleAssign(_, offset_var, offset),
	stor_offset = to_number(offset) + load_offset.



.decl StoreLoadActionParam(insn: Insn, to: Var, from: Var)

// store + load action data by directly mataching offset
StoreLoadActionParam(insn, to, from):-
	LoadActionParam(insn, to, from).

StoreLoadActionParam(insn, to, from):-
	StoreActionParam(address, offset, from),
	_Load(insn, address_var, offset, to),
	_AssignVar(_, address_var, address).


// store + load for loading from stored address
StoreLoadActionParam(insn, to, stored_address):-
	StoreLoadActionParamAddress(insn, to, stored_address, _).

StoreLoadActionParam(insn, to, param):-
	StoreLoadActionParamAddress(_, address, _, param),
	_Load(insn, address, 0, to).


// load action parameters
RootVar(from),
IntraCopyAssign(insn, to, from):-
	StoreLoadActionParam(insn, to, from).


// intermediate for action param to avoid double negation
.decl _InterCopyAssign(to: Var, from: Var)

_InterCopyAssign(to, from):-
	IntraCopyAssign(_, to, from).

// argument mapping
_InterCopyAssign(to, from):-
	_ActualArgs(_, func, index, from),
	_FormalArgs(_, func, index, to).

// return value mapping
_InterCopyAssign(to, from):-
	_FormalReturn(_, func, from),
	_ActualReturn(_, func, to).

// copys include mapping through parameters and return values
.decl InterCopyAssign(to: Var, from: Var)

InterCopyAssign(to, from):-
	_InterCopyAssign(to, from).

// load mapping, very crude but enough for checking alias
InterCopyAssign(to, from):-
	_Load(insn, from, _, to),
	!StoreLoadActionParam(insn, _, _).



.decl VarPointsTo(var1: Var, var2: Var)

// For require_auth, the user should only come from apply(...) or get_self()
// could restrict to use-def chain of require_auth and dbOps vars

// root -> root
VarPointsTo(var, var):-
	RootVar(var).

// Copys
VarPointsTo(to, var):-
	InterCopyAssign(to, from),
	VarPointsTo(from, var).




// inlcuding arithmetic operations
.decl ExtendedRootVar(var: Var)

ExtendedRootVar(var):-
	RootVar(var),
	!_AssignType(_, var, "Add"),
	!_AssignType(_, var, "Sub").



.decl ExtendedCopyAssign(to: Var, from: Var)

ExtendedCopyAssign(to, from):-
	InterCopyAssign(to, from).

ExtendedCopyAssign(to, from):-
	_AssignVar(insn, to, from),
	(_AssignType(insn, to, "Add");
	_AssignType(insn, to, "Sub")).



.decl ExtendedVarPointsTo(var: Var, to: Var)

// root -> root
ExtendedVarPointsTo(var, var):-
	ExtendedRootVar(var).

// Copys
ExtendedVarPointsTo(to, var):-
	ExtendedCopyAssign(to, from),
	ExtendedVarPointsTo(from, var).


// Propagation of parameters in apply including load/store
.comp ApplyParam{
	#if DEBUG && VERBOSE
		.output VarPointsToParam
		.output StoreParam
		.output StoreLoadParam
	#endif

	.decl VarPointsToParam(var: Var)

	VarPointsToParam(var):-
		ExtendedVarPointsTo(var, param),
		VarPointsToParam(param).

	// offset with store param insn
	.decl StoreParam(insn: Insn, offset: Var)

	StoreParam(insn, offset):-
		_Store(insn, offset, _, var),
		VarPointsToParam(var).


	.decl StoreLoadParam(storeInsn: Insn, loadInsn: Insn, loadTo: Var)

	// Load from store param by matching offsets
	StoreLoadParam(storeInsn, loadInsn, loadTo):-
		StoreParam(storeInsn, storeOffset),
		_Load(loadInsn, loadOffset, _, loadTo),
		!StoreLoadActionParam(loadInsn, _, _),
		ExtendedVarPointsTo(storeOffset, to),
		ExtendedVarPointsTo(loadOffset, to).


	VarPointsToParam(var):-
		StoreLoadParam(_, _, var).

	// may not be useful

	// reachable from store to load
	// .init store_dom_load = CFGDom

	// store_dom_load.Src(insn):-
	// 	StoreParam(insn, _).

	// store_dom_load.Target (insn):-
	// 	StoreLoadParam(_, insn, _).

	// VarPointsToParam(var):-
	// 	StoreLoadParam(store, load, var),
	// 	(store_dom_load.IntraSrcDomTarget(store, load);
	// 	store_dom_load.InterSrcDomTarget(store, load)).
}

// Taint self(reciever)
.init self = ApplyParam

self.VarPointsToParam(var):-
		_FormalArgs(_, "apply", 0, var).

self.VarPointsToParam(var):-
	_ActualReturn(_, "current_receiver", var).


// Taint code
.init code = ApplyParam

code.VarPointsToParam(var):-
		_FormalArgs(_, "apply", 1, var).




VarPointsTo(var, "_self"):-
	self.VarPointsToParam(var).

VarPointsTo(var, "_code"):-
	code.VarPointsToParam(var).



}
