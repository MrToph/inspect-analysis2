.comp Pointer{

.decl RootVar(var: Var)
.output RootVar

// Root Var includes const, arithmetic result and entry point parameters
RootVar(var):-
	_AssignType(_, var, _),
	!_AssignType(_, var, "Copy"),
	!_AssignType(_, var, "Call").


// assume uncalled funcation is the entry point
RootVar(var):-
	_FormalArgs(_, func, _, var),
	!_FuncCall(_, _, func).


// copys wihtin function
.decl IntraCopyAssign(insn: Insn, to: Var, from: Var)
.output IntraCopyAssign

IntraCopyAssign(insn, to, from):-
	_AssignVar(insn, to, from),
	_AssignType(insn, to, "Copy").

// load mapping, very crude but enough for checking alias
IntraCopyAssign(insn, to, from):-
	_Load(insn, from, _, to).


// copys include mapping through parameters and return values
.decl InterCopyAssign(to: Var, from: Var)
.output InterCopyAssign

InterCopyAssign(to, from):-
	IntraCopyAssign(_, to, from).

// argument mapping
InterCopyAssign(to, from):-
	_ActualArgs(_, func, index, from),
	_FormalArgs(_, func, index, to).

// return value mapping
InterCopyAssign(to, from):-
	_FormalReturn(_, func, from),
	_ActualReturn(_, func, to).


.decl VarPointsTo(var1: Var, var2: Var)
.output VarPointsTo

// For require_auth, the user should only come from apply(...) or get_self()
// could restrict to use-def chain of require_auth and dbOps vars

// root -> root
VarPointsTo(var, var):-
	RootVar(var).

// Copys
VarPointsTo(to, var):-
	InterCopyAssign(to, from),
	VarPointsTo(from, var).


}
