#include "control.dl"
#include "pointer.dl"
/*
Three layers:
	Intra-procedural: only check if the DBOps are dominated by require_auth whithin same function
	Inter-procedural: only check if require_auth dominate functions with DBOps (payer variables set mataching)
	Flow sensitive: check if require_auth dominate the function call with the according payer varaible (ordered matching)
*/
	
#define IntraProcedural 0
#define FlowSensitive 1


.init control = ControlFlow
.init pointer = Pointer

/* Auth Check */

/* Violation: 
1. DB Insn
2. Not preceed by require_auth()
*/


// DB Remove
// Unlikely called without DB find
// So only consider the find and remove that can be called from the same action

.decl ActionFuncReachable(from: Function, to: Function, insn: Insn)
.output ActionFuncReachable

ActionFuncReachable(from, to, insn):-
	_FuncCall(_, "apply", from),
	_FuncCall(insn, from, to).

ActionFuncReachable(from, to, insn):-
	ActionFuncReachable(from, mid, _),
	_FuncCall(insn, mid, to).

.decl DBRemove(insn: Insn, payer: Var)
.output DBRemove

DBRemove(removeInsn, payer):-
	ActionFuncReachable(action, "db_remove_i64", removeInsn),
	ActionFuncReachable(action, "db_find_i64", findInsn),
	_ActualArgs(findInsn, _, 3, payer).


.decl DBInsn(insn: Insn, payer: Var)
.output DBInsn

DBInsn(insn, payer):-
	_DBStore(insn, _, payer, _, _);
	_DBUpdate(insn, _, payer, _);
	DBRemove(insn, payer).


// Assume auth check and db access are in the same function
// reuqire_auth() called before db operation
.decl IntraAuthForDB(check: Insn, dbInsn: Insn)
.output IntraAuthForDB

/*
func(){
	BB:
		auth()
		dbOps()
}

*/

// check and dbOps are in same block
IntraAuthForDB(check, dbInsn):-
	DBInsn(dbInsn, _),
	_FuncCall(check, _, "require_auth"),
	control.ReachableInBB(check, dbInsn).

/*
func(){
	BB:
		auth()
	BB2:
		dbOps()
}

*/
// different block
IntraAuthForDB(check, dbInsn):-
	DBInsn(dbInsn, _),
	_FuncCall(check, _, "require_auth"),
	control.BasicBlockHead(dbHead, dbInsn),
	control.BasicBlockHead(checkHead, check),
	control.DominateBB(checkHead, dbHead). 


.decl SafeDBOps(dbInsn: Insn)
.output SafeDBOps

// only safe if the users are the same in both instructions
SafeDBOps(dbInsn):-
	IntraAuthForDB(check, dbInsn),
	_ActualArgs(check, "require_auth", 0, authVar),
	DBInsn(dbInsn, payerVar),
	pointer.VarPointsTo(authVar, user),
	pointer.VarPointsTo(payerVar, user).

// require_auth and DBOps are in different functions
#ifndef IntraProcedural


// Intra-procedural Violation
.decl Violation(insn: Insn)
.output Violation

Violation(insn):-
	DBInsn(insn, _),
	!SafeDBOps(insn).



/* Inter-procedural rules*/
#else

// Result obtianed from previous intra-procedrual analysis
.decl PossibleViolation(insn: Insn)
.output PossibleViolation

PossibleViolation(insn):-
	DBInsn(insn, _),
	!SafeDBOps(insn).



.decl AuthDomFunc(check: Insn, func: Function, funcCall: Insn)
.output AuthDomFunc

/*  Case 1:
func1{
	check();
	func2();
}
func2(){
	DBops();
}
*/

// check, func2
// different BB
AuthDomFunc(checkCall, newFunc, funcCall):-
	_FuncCall(checkCall, _, "require_auth"),
	control.BasicBlockHead(checkHead, checkCall),
	_FuncCall(funcCall, _, newFunc),
	control.BasicBlockHead(funcHead, funcCall),
	control.DominateBB(checkHead, funcHead).

// same BB
AuthDomFunc(checkCall, newFunc, funcCall):-
	_FuncCall(checkCall, _, "require_auth"),
	_FuncCall(funcCall, _, newFunc),
	control.ReachableInBB(checkCall, funcCall).

/* Case 2:
func1{
	check()
}
func2{
	func1();
	DBops();
	....
}
*/

.decl InterAuthForDB(check: Insn, dbInsn: Insn)
.output InterAuthForDB

// func1 and DBops are in different BB
InterAuthForDB(check, dbInsn):-
	_FuncCall(check, fromFunc, "require_auth"),
	_FuncCall(checkCall, _, fromFunc),
	PossibleViolation(dbInsn),
	control.BasicBlockHead(dbHead, dbInsn),
	control.BasicBlockHead(checkHead, checkCall),
	control.DominateBB(checkHead, dbHead).

// same BB
InterAuthForDB(check, dbInsn):-
	_FuncCall(check, fromFunc, "require_auth"),
	_FuncCall(checkCall, _, fromFunc),
	PossibleViolation(dbInsn),
	control.ReachableInBB(checkCall, dbInsn). 

/* Case 3:
checkFunc{
	check()
}
fromFunc{
	checkFunc();
	newFunc();
}
newFunc(){
	DBops();
}
*/

// check, newFunc

// checkFunc and newFunc are in different BB
AuthDomFunc(check, newFunc, newFuncCall):-
	_FuncCall(check, checkFunc, "require_auth"),
	_FuncCall(checkCall, fromFunc, checkFunc),
	_FuncCall(newFuncCall, fromFunc, newFunc),
	control.BasicBlockHead(newFuncHead, newFuncCall),
	control.BasicBlockHead(checkHead, checkCall),
	control.DominateBB(checkHead, newFuncHead).


// same BB
AuthDomFunc(check, newFunc, newFuncCall):-
	_FuncCall(check, checkFunc, "require_auth"),
	_FuncCall(checkCall, fromFunc, checkFunc),
	_FuncCall(newFuncCall, fromFunc, newFunc),
	control.ReachableInBB(checkCall, newFuncCall).
	
// recursion, can be overlooked for performance
AuthDomFunc(check, newFunc, newFuncCall):-
	AuthDomFunc(check, fromFunc, _),
	_FuncCall(newFuncCall, fromFunc, newFunc).


.decl AuthVarForDB(var: Var, dbInsn: Insn)
.output AuthVarForDB

// Case 1 & 3
AuthVarForDB(var, dbInsn):-
	AuthDomFunc(check, func, _),
	_ActualArgs(check, "require_auth", 0, authVar),
	pointer.VarPointsTo(authVar, var),
	PossibleViolation(dbInsn),
	_FuncInsn(func, dbInsn).

// Case 2
AuthVarForDB(var, dbInsn):-
	InterAuthForDB(check, dbInsn),
	_ActualArgs(check, "require_auth", 0, authVar),
	pointer.VarPointsTo(authVar, var).


/* Case:
	Func1(){
			1: require_auth (A) // Auth(A)
			2: Func2(A)
			3: Func2(B)
		}

		Func2(C){
			4: DbOps(C) // C -> A, C -> B
	}

	Expect violation at 4
*/

// If miss some payer auths 
.decl Violation(insn: Insn)
.output Violation

Violation(dbInsn):-
	PossibleViolation(dbInsn),
	!AuthVarForDB(to, dbInsn),
	DBInsn(dbInsn, payer),
	pointer.VarPointsTo(payer, to).


/* Flow Sensitive rules*/
#ifdef FlowSensitive

/* Case
	Func1(){
		1: require_auth (B) // Auth(B)
		2: Func2(A) // A
		3: require_auth (A) // Auth(A)
		4: Func2(B) // B
	}
	Func2(C){
		5: Db_insn: Db_Store(C) // C -> A, C -> B
	}

	Expect violation at 5
*/


.decl PayerInFunc(dbInsn: Insn, payerVar: Var, func: Function)
.output PayerInFunc

// payerVar in dbOps
PayerInFunc(dbInsn, payerVar, func):-
	PossibleViolation(dbInsn),
	_FuncInsn(func, dbInsn),
	DBInsn(dbInsn, payerVar).

// All the payer var within the function
PayerInFunc(dbInsn, to, func):-
	PayerInFunc(dbInsn, from, func),
	pointer.IntraCopyAssign(_, from, to).

// capture payer points to if payer is passed by parameters
.decl PayerInFuncCallPointsTo(dbInsn: Insn, to: Var, funcCall: Insn)
.output PayerInFunc

PayerInFuncCallPointsTo(dbInsn, to, funcCall):-
	PayerInFunc(dbInsn, formalVar, func),
	_FormalArgs(_, func, index, formalVar),
	_ActualArgs(funcCall, func, index, actualVar),
	pointer.VarPointsTo(actualVar, to).

// For mixed order
Violation(dbInsn):-
	PayerInFuncCallPointsTo(dbInsn, to, funcCall),
	!AuthDomFunc(check, _, funcCall),
	_ActualArgs(check, "require_auth", 0, authVar),
	pointer.VarPointsTo(authVar, to).

#endif

#endif


